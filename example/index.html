<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unsea Browser Example & Testing Interface</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }

        .result {
            background: #f4f4f4;
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            word-break: break-all;
        }

        .success {
            color: green;
        }

        .error {
            color: red;
        }

        button {
            background: #007cba;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }

        button:hover {
            background: #005a87;
        }

        .tabs {
            margin-bottom: 20px;
        }

        .tab-btn {
            background: #eee;
            color: #333;
            border: none;
            padding: 10px 20px;
            border-radius: 5px 5px 0 0;
            margin-right: 2px;
            cursor: pointer;
            font-weight: bold;
        }

        .tab-btn.active {
            background: #007cba;
            color: white;
        }

        .tab-content {
            border: 1px solid #ddd;
            border-top: none;
            padding: 20px;
            border-radius: 0 0 5px 5px;
            background: #fafbfc;
        }
    </style>
</head>

<body>
    <h1>üîê Unsea Browser Example & Testing Interface</h1>
    <p>This interface demonstrates the Unsea cryptographic toolkit with comprehensive testing and examples using the bundled version. All functions are available globally via <code>window.unsea</code> for debugging.</p>

    <div class="tabs">
        <button class="tab-btn" onclick="showTab('crypto')" id="tab-crypto">Crypto Tests</button>
        <button class="tab-btn" onclick="showTab('session')" id="tab-session">Session Storage</button>
        <button class="tab-btn" onclick="showTab('derive')" id="tab-derive">Key Derivation</button>
    </div>

    <div id="tab-content-crypto" class="tab-content">
        <button onclick="runExample()">Run Cryptographic Tests</button>
        <button onclick="clearOutput()">Clear Output</button>
        <button onclick="showSecurityInfo()">Show Security Info</button>
        <div id="output"></div>
    </div>

    <div id="tab-content-session" class="tab-content" style="display:none;">
        <button onclick="createUserSession()">Create User Sessions</button>
        <button onclick="recallUserSession()">Recall User Sessions</button>
        <button onclick="clearUserSession()">Clear User Sessions</button>
        <button onclick="testRefreshPersistence()">Test Refresh Persistence</button>
        <button onclick="clearOutput()">Clear Output</button>
        <div id="output-session"></div>
    </div>

    <div id="tab-content-derive" class="tab-content" style="display:none;">
        <h2>üß¨ Key Derivation Test</h2>
        <div style="position:relative; margin-bottom:10px;">
            <textarea id="deriveInput" rows="3" style="width:100%; font-size:1.1em;"
                placeholder="Type your passphrase or random text here..."></textarea>
            <span id="entropyCounter"
                style="position:absolute; top:5px; right:10px; background:#eee; padding:2px 8px; border-radius:12px; font-size:0.9em;">Chars:
                0</span>
        </div>
        <button onclick="deriveKeypair()">Derive Keypair</button>
        <div id="deriveStatus" class="result"></div>
        <div id="deriveResult" class="result"></div>
    </div>

    <script type="module">
        import {
            generateRandomPair,
            signMessage,
            verifyMessage,
            encryptMessageWithMeta,
            decryptMessageWithMeta,
            encryptBySenderForReceiver,
            decryptBySenderForReceiver,
            exportToPEM,
            importFromPEM,
            exportToJWK,
            importFromJWK,
            save,
            recall,
            clear,
            generateWork,
            verifyWork,
            generateSignedWork,
            verifySignedWork,
            derivePair,
            getSecurityInfo
        } from '../dist/unsea.mjs';

        // Make unsea available globally for debugging (like the development server)
        window.unsea = {
            generateRandomPair,
            signMessage,
            verifyMessage,
            encryptMessageWithMeta,
            decryptMessageWithMeta,
            encryptBySenderForReceiver,
            decryptBySenderForReceiver,
            exportToPEM,
            importFromPEM,
            exportToJWK,
            importFromJWK,
            save,
            recall,
            clear,
            generateWork,
            verifyWork,
            generateSignedWork,
            verifySignedWork,
            derivePair,
            getSecurityInfo
        };


        // Tab switching logic
        const TABS = ['crypto', 'session', 'derive'];
        function updateTabUI(tab) {
            const chosen = TABS.includes(tab) ? tab : 'crypto';
            TABS.forEach(t => {
                document.getElementById('tab-content-' + t).style.display = (t === chosen) ? '' : 'none';
                document.getElementById('tab-' + t).classList.toggle('active', t === chosen);
            });
        }
        function getTabFromHash() {
            const h = (location.hash || '').replace('#', '').toLowerCase();
            return TABS.includes(h) ? h : 'crypto';
        }
        function showTab(tab) {
            const target = TABS.includes(tab) ? tab : 'crypto';
            if (location.hash !== '#' + target) {
                location.hash = target;
            } else {
                updateTabUI(target);
            }
        }
        window.addEventListener('hashchange', () => updateTabUI(getTabFromHash()));
        // Initialize from hash (or default)
        updateTabUI(getTabFromHash());

        // Output elements for each tab
        const output = document.getElementById('output');
        const outputSession = document.getElementById('output-session');
        const deriveInput = document.getElementById('deriveInput');
        const entropyCounter = document.getElementById('entropyCounter');
        const deriveStatus = document.getElementById('deriveStatus');
        const deriveResult = document.getElementById('deriveResult');

        // Update log/clearOutput to use correct output div based on tab
        function getActiveOutput() {
            if (!document.getElementById('tab-content-crypto').style.display || document.getElementById('tab-content-crypto').style.display === '') {
                return output;
            } else if (!document.getElementById('tab-content-session').style.display || document.getElementById('tab-content-session').style.display === '') {
                return outputSession;
            }
            return output;
        }
        function log(message, isError = false) {
            const out = getActiveOutput();
            const div = document.createElement('div');
            div.className = `result ${isError ? 'error' : 'success'}`;
            div.innerHTML = message;
            out.appendChild(div);
        }
        function clearOutput() {
            output.innerHTML = '';
            outputSession.innerHTML = '';
        }

        // Show Security Info function (from index.html)
        window.showSecurityInfo = function() {
            const out = getActiveOutput();
            try {
                const info = getSecurityInfo();
                const div = document.createElement('div');
                div.className = 'result success';
                div.innerHTML = `
                    <strong>Security Information:</strong><br>
                    Version: ${info.version}<br>
                    Algorithms: ${JSON.stringify(info.algorithms, null, 2)}<br>
                    Security Enhancements: ${info.securityEnhancements.join(', ')}
                `;
                out.appendChild(div);
            } catch (error) {
                log(`Error getting security info: ${error.message}`, true);
            }
        }

        async function runExample() {
            clearOutput();
            log('üöÄ Starting Unsea Browser Tests...');

            try {
                console.log('DEBUG: Starting tests...');
                // Test 1: Generate keypairs
                log('1Ô∏è‚É£ Generating keypairs...');
                const alice = await generateRandomPair();
                const bob = await generateRandomPair();
                log(`Alice's public key: ${alice.pub.substring(0, 30)}...`);
                log(`Bob's public key: ${bob.pub.substring(0, 30)}...`);

                // Test 2: Sign and verify
                log('2Ô∏è‚É£ Testing message signing...');
                const message = "Hello from browser! This is a test message.";
                const signature = await signMessage(message, alice.priv);
                const isValid = await verifyMessage(message, signature, alice.pub);
                log(`Message: "${message}"`);
                log(`Signature: ${signature.substring(0, 30)}...`);
                log(`Verification: ${isValid ? '‚úÖ Valid' : '‚ùå Invalid'}`);

                // Test 3: Encrypt and decrypt
                log('3Ô∏è‚É£ Testing message encryption...');
                const secretMessage = "This is a secret message! üîí";
                const encrypted = await encryptMessageWithMeta(secretMessage, bob);
                const decrypted = await decryptMessageWithMeta(encrypted, bob.epriv);
                log(`Original: "${secretMessage}"`);
                log(`Encrypted: ${encrypted.ciphertext.substring(0, 30)}...`);
                log(`Decrypted: "${decrypted}"`);
                log(`Match: ${secretMessage === decrypted ? '‚úÖ Success' : '‚ùå Failed'}`);

                // Test 4: Proof of Work
                log('4Ô∏è‚É£ Testing Proof of Work...');
                const challengeData = {
                    challenge: "Browser proof of work test",
                    timestamp: Date.now()
                };
                const work = await generateWork(challengeData, 3, 50000);
                const workValid = await verifyWork(work);
                log(`Challenge: ${JSON.stringify(challengeData)}`);
                log(`Nonce: ${work.nonce}`);
                log(`Hash: ${work.hashHex}`);
                log(`Duration: ${work.duration}ms`);
                log(`Verification: ${workValid.valid ? '‚úÖ Valid' : '‚ùå Invalid'}`);

                console.log('DEBUG: About to start test 5...');
                // Test 5: Signed Proof of Work
                log('5Ô∏è‚É£ Testing Signed Proof of Work...');
                console.log('DEBUG: Starting test 5 execution...');
                try {
                    console.log('DEBUG: Creating signed challenge data...');
                    const signedChallengeData = {
                        challenge: "Browser signed proof test",
                        user: alice.pub.substring(0, 20) + '...',
                        timestamp: Date.now()
                    };
                    console.log('DEBUG: About to call generateSignedWork...');
                    const signedWork = await generateSignedWork(signedChallengeData, alice.priv, 3, 25000);
                    console.log('DEBUG: generateSignedWork completed, about to verify...');
                    const signedVerification = await verifySignedWork(signedWork, alice.pub);
                    console.log('DEBUG: verifySignedWork completed, logging results...');
                    log(`Signed Challenge: ${JSON.stringify(signedChallengeData)}`);
                    log(`Nonce: ${signedWork.nonce}`);
                    log(`Hash: ${signedWork.hashHex}`);
                    log(`Duration: ${signedWork.duration}ms`);
                    log(`Signature Valid: ${signedVerification.signatureValid ? '‚úÖ Valid' : '‚ùå Invalid'}`);
                    log(`Work Valid: ${signedVerification.workValid ? '‚úÖ Valid' : '‚ùå Invalid'}`);
                    log(`Overall Valid: ${signedVerification.valid ? '‚úÖ Valid' : '‚ùå Invalid'}`);
                    console.log('DEBUG: Test 5 completed successfully');
                } catch (test5Error) {
                    console.error('DEBUG: Test 5 error caught:', test5Error);
                    log(`‚ùå Test 5 Failed: ${test5Error.message}`, true);
                    console.error('Test 5 error:', test5Error);
                }

                // Test 6: Key formats
                log('6Ô∏è‚É£ Testing key format conversion...');
                try {
                    const pemKey = await exportToPEM(alice.priv);
                    const importedFromPem = await importFromPEM(pemKey);
                    const jwkKey = await exportToJWK(alice.priv);
                    const importedFromJwk = await importFromJWK(jwkKey);
                    log(`PEM export/import: ${alice.priv === importedFromPem ? '‚úÖ Success' : '‚ùå Failed'}`);
                    log(`JWK export/import: ${alice.priv === importedFromJwk ? '‚úÖ Success' : '‚ùå Failed'}`);
                } catch (test6Error) {
                    log(`‚ùå Test 6 Failed: ${test6Error.message}`, true);
                    console.error('Test 6 error:', test6Error);
                }

                // Test 7: Security Information
                log('7Ô∏è‚É£ Displaying Security Information...');
                try {
                    const securityInfo = getSecurityInfo();
                    log(`Library Version: ${securityInfo.version}`);
                    log(`Signing Algorithm: ${securityInfo.algorithms.signing}`);
                    log(`Encryption Algorithm: ${securityInfo.algorithms.encryption}`);
                    log(`Security Enhancements: ${securityInfo.securityEnhancements.length} items`);
                } catch (test7Error) {
                    log(`‚ùå Test 7 Failed: ${test7Error.message}`, true);
                    console.error('Test 7 error:', test7Error);
                }

                // Test 8: Private Chat Encryption
                log('8Ô∏è‚É£ Testing Private Chat Encryption...');
                try {
                    const bobPair = await generateRandomPair();
                    const chatMessage1 = "Secret message from Alice to Bob";
                    const chatMessage2 = "Reply from Bob to Alice";
                    
                    // Alice encrypts a message for Bob using encryption keys
                    const aliceToBob = await encryptBySenderForReceiver(chatMessage1, alice.epriv, bobPair.epub);
                    log(`Alice‚ÜíBob encrypted: ${aliceToBob.ciphertext.substring(0, 50)}...`);
                    
                    // Bob decrypts the message from Alice using encryption keys
                    const bobDecrypted = await decryptBySenderForReceiver(aliceToBob, alice.epub, bobPair.epriv);
                    log(`Bob decrypted: "${bobDecrypted}"`);
                    
                    // Bob encrypts a reply for Alice (bidirectional)
                    const bobToAlice = await encryptBySenderForReceiver(chatMessage2, bobPair.epriv, alice.epub);
                    log(`Bob‚ÜíAlice encrypted: ${bobToAlice.ciphertext.substring(0, 50)}...`);
                    
                    // Alice decrypts Bob's reply
                    const aliceDecrypted = await decryptBySenderForReceiver(bobToAlice, bobPair.epub, alice.epriv);
                    log(`Alice decrypted: "${aliceDecrypted}"`);
                    
                    const test1Pass = chatMessage1 === bobDecrypted;
                    const test2Pass = chatMessage2 === aliceDecrypted;
                    log(`Bidirectional chat test: ${test1Pass && test2Pass ? '‚úÖ Success' : '‚ùå Failed'}`);
                    log(`Alice‚ÜíBob: ${test1Pass ? '‚úÖ' : '‚ùå'} | Bob‚ÜíAlice: ${test2Pass ? '‚úÖ' : '‚ùå'}`);
                } catch (test8Error) {
                    log(`‚ùå Test 8 Failed: ${test8Error.message}`, true);
                    console.error('Test 8 error:', test8Error);
                }

                log('üéâ All browser tests completed successfully!');

            } catch (error) {
                log(`‚ùå Error: ${error.message}`, true);
                console.error(error);
            }
        }

        async function createUserSession() {
            clearOutput();
            log('üöÄ Testing Session Storage Functions (like Gun\'s user.recall())...');

            try {
                // Generate a test keypair
                log('1Ô∏è‚É£ Generating test keypair...');
                const testUser = await generateRandomPair();
                log(`Generated keypair for testing`);
                log(`Public key: ${testUser.pub.substring(0, 30)}...`);

                // Test save function
                log('2Ô∏è‚É£ Saving keypair to session storage...');
                const saveResult = save(testUser, 'testUser');
                log(`Save result: ${saveResult ? '‚úÖ Success' : '‚ùå Failed'}`);


                // Test saving multiple users
                log('5Ô∏è‚É£ Testing multiple user sessions...');
                const alice = await generateRandomPair();
                const bob = await generateRandomPair();

                save(alice, 'alice');
                save(bob, 'bob');
                log('Saved Alice and Bob keypairs');


            } catch (error) {
                log(`‚ùå Error: ${error.message}`, true);
                console.error(error);
            }
        }

        async function recallUserSession() {
            clearOutput();
            log('üöÄ Testing Session Storage Functions (like Gun\'s user.recall())...');

            try {

                // Test recall function
                log('3Ô∏è‚É£ Recalling keypair from session storage...');
                const recalledUser = recall('testUser');
                if (recalledUser) {
                    log(`‚úÖ Recall successful!`);
                    log(`Public key: ${recalledUser.pub}`);
                    log(`Private key: ${recalledUser.priv}`);

                    // Test functionality with recalled keypair
                    log('4Ô∏è‚É£ Testing recalled keypair functionality...');
                    const testMessage = 'Testing recalled keypair signing';
                    const signature = await signMessage(testMessage, recalledUser.priv);
                    const isValid = await verifyMessage(testMessage, signature, recalledUser.pub);
                    log(`Signature with recalled keypair: ${isValid ? '‚úÖ Valid' : '‚ùå Invalid'}`);
                } else {
                    log('‚ùå Recall failed');
                    return;
                }

                const recalledAlice = recall('alice');
                const recalledBob = recall('bob');
                log(`Alice recalled: ${recalledAlice ? '‚úÖ Success' : '‚ùå Failed'}`);
                log(`Bob recalled: ${recalledBob ? '‚úÖ Success' : '‚ùå Failed'}`);
            } catch (error) {
                log(`‚ùå Error: ${error.message}`, true);
                console.error(error);
            }
        }

        async function clearUserSession() {
            clearOutput();
            log('üöÄ Testing Session Storage Functions (like Gun\'s user.recall())...');

            try {

                // Test clear function
                log('6Ô∏è‚É£ Testing clear function...');
                const clearResult = clear('testUser');
                log(`Clear testUser: ${clearResult ? '‚úÖ Success' : '‚ùå Failed'}`);

                const clearedRecall = recall('testUser');
                log(`testUser cleared: ${clearedRecall === null ? '‚úÖ Success' : '‚ùå Still exists'}`);

                // Clear all UnSEA data
                log('7Ô∏è‚É£ Clearing all UnSEA session data...');
                clear(null); // Clear all
                const aliceAfterClear = recall('alice');
                const bobAfterClear = recall('bob');
                log(`All data cleared: ${aliceAfterClear === null && bobAfterClear === null ? '‚úÖ Success' : '‚ùå Failed'}`);

                log('üéâ Session storage tests completed successfully!');
                log('üí° Keypairs are now stored in your browser session - refresh to test persistence!');

            } catch (error) {
                log(`‚ùå Error: ${error.message}`, true);
                console.error(error);
            }
        }

        // Test Refresh Persistence Function (from index.html)
        window.testRefreshPersistence = async function() {
            clearOutput();
            log('üîÑ Testing Session Storage Persistence Across Page Refreshes...');
            
            try {
                // First check if there are any existing stored keypairs
                const existingUser = recall('persistenceTest');
                
                if (existingUser) {
                    log('‚úÖ Found existing keypair from previous session!');
                    log(`Public key: ${existingUser.pub.substring(0, 30)}...`);
                    
                    // Test that the recalled keypair still works
                    const testMessage = 'Testing persistence after refresh';
                    const signature = await signMessage(testMessage, existingUser.priv);
                    const isValid = await verifyMessage(testMessage, signature, existingUser.pub);
                    log(`Keypair still functional: ${isValid ? '‚úÖ Yes' : '‚ùå No'}`);
                    
                    log('üóëÔ∏è Clearing test data...');
                    clear('persistenceTest');
                    log('Test completed - data cleared');
                    
                } else {
                    log('üìù No existing keypair found. Creating one for persistence test...');
                    const newKeypair = await generateRandomPair();
                    log(`Generated new keypair: ${newKeypair.pub.substring(0, 30)}...`);
                    
                    // Save it
                    const saveResult = save(newKeypair, 'persistenceTest');
                    log(`Saved to session storage: ${saveResult ? '‚úÖ Success' : '‚ùå Failed'}`);
                    
                    log('üîÑ Now REFRESH this page and click this button again to test persistence!');
                    log('üí° Session storage persists until you close this browser tab/window');
                }
                
            } catch (error) {
                log(`‚ùå Error: ${error.message}`, true);
                console.error(error);
            }
        }

        // Auto-persistence checking on page load (from index.html)
        window.addEventListener('load', async function() {
            const persistedUser = recall('persistenceTest');
            
            if (persistedUser) {
                // Found persisted data - test it works
                try {
                    const testMessage = 'Auto-testing persisted keypair';
                    const signature = await signMessage(testMessage, persistedUser.priv);
                    const isValid = await verifyMessage(testMessage, signature, persistedUser.pub);
                    
                    const statusDiv = document.createElement('div');
                    statusDiv.className = 'result success';
                    statusDiv.innerHTML = `
                        üéâ <strong>PERSISTENCE TEST PASSED!</strong><br>
                        ‚úÖ Keypair survived page refresh<br>
                        ‚úÖ Keypair still functional: ${isValid ? 'YES' : 'NO'}<br>
                        üìù Public key: ${persistedUser.pub.substring(0, 30)}...<br>
                        <button onclick="clear('persistenceTest'); location.reload();" style="margin-top: 10px;">Clear Test Data</button>
                    `;
                    outputSession.appendChild(statusDiv);
                } catch (error) {
                    const statusDiv = document.createElement('div');
                    statusDiv.className = 'result error';
                    statusDiv.innerHTML = `‚ùå <strong>Persisted keypair found but failed to work:</strong> ${error.message}`;
                    outputSession.appendChild(statusDiv);
                }
            }
        });

        function updateEntropyCounter() {
            const val = deriveInput.value;
            const entropy = val.length;
            entropyCounter.textContent = `Chars: ${entropy}`;
            if (entropy < 16) {
                entropyCounter.style.background = '#ffd6d6';
                deriveStatus.className = 'result error';
                deriveStatus.textContent = '‚ùå Not enough characters (min 16 recommended)';
            } else {
                entropyCounter.style.background = '#d6ffd6';
                deriveStatus.className = 'result success';
                deriveStatus.textContent = '‚úÖ Sufficient length';
            }
            deriveResult.textContent = '';
        }
        deriveInput && deriveInput.addEventListener('input', updateEntropyCounter);
        if (deriveInput) updateEntropyCounter();

        async function deriveKeypair() {
            const val = deriveInput.value;
            const entropy = val.length;
            if (entropy < 16) {
                deriveStatus.className = 'result error';
                deriveStatus.textContent = '‚ùå Not enough characters to derive a secure keypair!';
                deriveResult.textContent = '';
                return;
            }
            deriveStatus.className = 'result success';
            deriveStatus.textContent = '‚è≥ Deriving keypair...';
            try {
                const keypair = await derivePair(val);
                deriveResult.className = 'result success';
                deriveResult.innerHTML = `<b>Derived Keypair:</b><br>pub: <code>${keypair.pub}</code><br>priv: <code>${keypair.priv}</code><br>epub: <code>${keypair.epub}</code><br>epriv: <code>${keypair.epriv}</code>`;
                deriveStatus.textContent = '‚úÖ Keypair derived successfully!';
            } catch (e) {
                deriveResult.className = 'result error';
                deriveResult.textContent = '‚ùå Error: ' + e.message;
                deriveStatus.textContent = '‚ùå Derivation failed';
            }
        }

        // expose handlers for inline onclick attributes
        window.showTab = showTab;
        window.runExample = runExample;
        window.createUserSession = createUserSession;
        window.recallUserSession = recallUserSession;
        window.clearUserSession = clearUserSession;
        window.deriveKeypair = deriveKeypair;
        window.clearOutput = clearOutput;
        // Additional functions from index.html:
        window.testRefreshPersistence = testRefreshPersistence;
        window.showSecurityInfo = showSecurityInfo;
    </script>
</body>

</html>